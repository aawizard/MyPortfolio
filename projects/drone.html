<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">

  <title>Ananya-Portfolio</title>
    <meta content="" name="description">
  <meta content="" name="keywords">

  <!-- Favicons -->
  <!-- <link href="assets/img/favicon.png" rel="icon"> -->
  <!-- <link href="assets/img/apple-touch-icon.png" rel="apple-touch-icon"> -->

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=https://fonts.googleapis.com/css?family=Inconsolata:400,500,600,700|Raleway:400,400i,500,500i,600,600i,700,700i" rel="stylesheet">

  <!-- Vendor CSS Files -->
  <link href="../assets/vendor/aos/aos.css" rel="stylesheet">
  <link href="../assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="../assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="../assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">

  <!-- Template Main CSS File -->
  <link href="../assets/css/style.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <!-- =======================================================
  * Template Name: MyPortfolio
  * Updated: Sep 18 2023 with Bootstrap v5.3.2
  * Template URL: https://bootstrapmade.com/myportfolio-bootstrap-portfolio-website-template/
  * Author: BootstrapMade.com
  * License: https://bootstrapmade.com/license/
  ======================================================== -->
</head>

<body>
  <nav class="navbar navbar-light custom-navbar">
    <div class="container">
      <a class="navbar-brand" href="../index.html">Ananya Agarwal</a>
      <div class="row-md-1">
      <a href="../index.html">Projects</a>
      <a href="../about.html">About Me</a>
      <a href="../resume.html">Resume</a>
      <a href="../contact.html">Contact</a>
        <span></span>
      </a>
    </div>
  </nav>


  <main id="main">

    <section class="section pb-5">
        <div class="container">
            <div class="row  align-items-end">
                <div class="col-md-6 text-center mx-auto" data-aos="fade-up">
                    <h2> Minimum snap drone control with mathematical simulation</h2>
                    
                </div>
            </div>

            <div class="col discription">
                <div class="col mb-md-0 " data-aos="fade-up">
                    <h3>Brief Overview</h3>
                    <p >The objective is to achieve precise and efficient quadrotor movement from point A to B in the minimum possible time. The project involves developing a mathematical simulation for a given hardware design, replicating its controls, creating a ROS-based control loop with a PID controller, and implementing a minimum snap trajectory generator and trajectory controller.</p>

                    <h3>Video demo</h3>
                    <!-- <p class="text-center"><iframe width="560" height="315" src="https://www.youtube.com/embed/PGhHzJX8ALY?si=nYK3LCMetfZ7e3XH" frameborder="0" allowfullscreen></iframe></p> -->
                     TODO
                    <h3>Hardware setup</h3>
                    <p>
                        The quadrotor hardware includes a <b>Betaflight flight controller</b>, a <b>Raspberry Pi 0</b> for processing, and <b>1103 brushless motors</b> with KV ratings of 8000 to 15000 RPM/V. The controller takes inputs such as <b>roll, pitch, yaw (1050-1900 range)</b>, and <b>throttle (1000-1900 range)</b>.
                      </p>
                      
                      <p>
                        The drone's position is independently tracked using <b>OptiTrack</b>, providing precise positional data for validation and control loop optimization.
                      </p>
                      
                    <p class="text-center"><img src="../assets/img/drone_hardware.jpeg" alt="Image" class="img-fluid mx-auto d-block "  width="360" height="215"></p>
                    <p></p>
                    <h3>Software setup</h3>
                    <p>
                        The simulation is developed in <b>Python</b> and <b>ROS2</b> visualizing in <b>Rviz</b>. The simulation includes a quadrotor model with a <b>minimum snap trajectory generator</b> and a <b>trajectory controller</b>.
                      </p>
                      
                      <p>
                        The control loop is implemented in <b>ROS</b> using <b>Python</b> and <b>rospy</b>. The control loop includes a <b>PID controller</b> or <b>Trajectory controller</b> for roll, pitch, yaw, and throttle.
                      </p>
                    <!-- space of 1 line -->
                    <p></p>    
                    <details>
                    <summary  style="font-size: 1.25em; font-weight: bold;">Simulation</summary>
                    
                      <div>
                       
                        <p>
                          The control inputs provided to the quadrotor are as follows:
                        </p>
                        <ul>
                          <li><b>Roll, Pitch, and Yaw:</b> Input values range from 1050 to 1900. A value of 1500 corresponds to the neutral position. Roll and pitch inputs are scaled to absolute angles based on the maximum tilt angle set in the Betaflight flight controller.</li>
                          <li><b>Throttle:</b> Input values range from 1000 to 1900, where 1000 represents 0% thrust and 1900 corresponds to 100% thrust.</li>
                        </ul>
                    
                        <h5><b>Control and Simulation Process:</b></h5>
                        <ol>
                          <li><b>PWM to Angle Conversion:</b> Roll and pitch targets are calculated using the formula:
                            <p>
                              \[
                              \text{Target Angle} = \left( \frac{\text{Input} - 1050}{900} \times 110 \right) - 55
                              \]
                            </p>
                          </li>
                          <li><b>Thrust Calculation:</b> The thrust is calculated as:
                            <p>
                              \[
                              \text{Thrust} = \frac{\text{Input} - 1000}{1000} \times \text{Max Thrust}
                              \]
                            </p>
                          </li>
                          <li><b>PID Control:</b> PID controllers are implemented for roll and pitch stabilization. The error is the difference between the target angle and the current angle:
                            <p>
                              \[
                              \text{Error}_{\text{roll}} = \text{Target Roll (rad)} - \text{Current Roll (rad)}
                              \]
                              \[
                              \text{Error}_{\text{pitch}} = \text{Target Pitch (rad)} - \text{Current Pitch (rad)}
                              \]
                            </p>
                            The control effort is updated using the PID formula:
                            <p>
                              \[
                              \text{Control Effort} = K_p \times \text{Error} + K_i \times \int \text{Error} \, dt + K_d \times \frac{d(\text{Error})}{dt}
                              \]
                            </p>
                          </li>
                          <li><b>Thrust Transformation:</b> The thrust in the body frame is converted to the world frame using the rotation matrix:
                            <p>
                              \[
                              \mathbf{Thrust}_{\text{GF}} = \mathbf{R}_{\text{BF→GF}} \times \begin{bmatrix} 0 \\ 0 \\ \text{Thrust} \end{bmatrix}
                              \]
                            </p>
                            Where \(\mathbf{R}_{\text{BF→GF}}\) is the rotation matrix derived from the roll, pitch, and yaw angles.
                          </li>
                          <li><b>Position Updates:</b> The acceleration in each axis is computed, and velocities and positions are updated:
                            <p>
                              \[
                              \ddot{z} = \frac{\text{Thrust}_{z, \text{GF}}}{m} - g
                              \]
                              \[
                              \ddot{x} = -\frac{\text{Thrust}_{x, \text{GF}}}{m}, \quad \ddot{y} = -\frac{\text{Thrust}_{y, \text{GF}}}{m}
                              \]
                              \[
                              \dot{x} = \dot{x} + \ddot{x} \cdot dt, \quad x = x + \dot{x} \cdot dt
                              \]
                            </p>
                            Similar equations apply for \(y\) and \(z\).
                          </li>
                        </ol>
                    
                        <h5><b>Key Considerations:</b></h5>
                        <ul>
                          <li><b>Ground Constraint:</b> If \(z < 0\), the quadrotor is grounded, and all velocities are set to zero.</li>
                          <li><b>Random Perturbations:</b> Small random variations are introduced to \(p\) and \(q\) to simulate real-world disturbances.</li>
                        </ul>
                        <h5>Drone Marker Visualization</h5>
                        <p>
                          The simulation includes a visualization of the drone as a marker in Rviz. While the marker does not accurately represent the physical dimensions of the drone, it serves as a visual aid to demonstrate its position and orientation during the simulation. Below is a snapshot of the visualization:
                        </p>
                        <p class="text-center">
                          <img src="../assets/img/drone_visualization.png" alt="Drone Marker Visualization" class="img-fluid mx-auto d-block" width="360" height="215">
                        </p>

                      </div>
                    </details>
                                       
                    <details>
                      <summary style="font-size: 1.25em; font-weight: bold;">Controller On Board</summary>
                      <div style="margin-left: 20px;">
                        <h5>Raspberry Pi Zero Communication</h5>
                        <p>
                          The Raspberry Pi Zero serves as the intermediary between the control commands and the Betaflight flight controller on the quadrotor. It communicates with the base station computer through a UDP connection, running at a frequency of 100 Hz. The control messages it sends include throttle, roll, pitch, yaw, arm/disarm status, and flight mode.
                        </p>
                        <h5>Control Commands Sent to the Raspberry Pi</h5>
                        <ul>
                          <li><b>Throttle</b>: The throttle value to control the motor speed.</li>
                          <li><b>Roll</b>: The roll command to control the drone's roll angle.</li>
                          <li><b>Pitch</b>: The pitch command to control the drone's pitch angle.</li>
                          <li><b>Yaw</b>: The yaw command to control the drone's yaw angle.</li>
                          <li><b>Aux1 (Arm/Disarm)</b>: Controls the arm/disarm state of the drone.
                            <ul>
                              <li><b>1000</b>: Disarm</li>
                              <li><b>1800</b>: Arm</li>
                            </ul>
                          </li>
                          <li><b>Aux2 (Mode)</b>: Controls the flight mode of the drone. There are two modes:
                            <ul>
                              <li><b>Angle Mode</b>: Stabilized flight mode, where the drone tries to maintain a fixed angle.</li>
                              <li><b>Horizon Mode</b>: A hybrid mode between manual and stabilized, with limited angle control.</li>
                            </ul>
                          </li>
                        </ul>
                        
                        <h5>Communication with Betaflight Controller</h5>
                        <p>
                          The Raspberry Pi uses the <b>yamspy</b> library to communicate with the Betaflight controller board. The communication is based on the MSP (Multiwii Serial Protocol) to send control commands to the flight controller.
                        </p>
                        
                        <h5>Control Node</h5>
                        <p>
                          The drone control node subscribes to the <code>/quad_ctrl</code> topic and receives the control commands. It then sends the commands to the Raspberry Pi through UDP, ensuring smooth control of the drone.
                        </p>
                      </div>
                    </details>
                    
                    <details>
                      <summary style="font-size: 1.25em; font-weight: bold;">Communication with Optitrack</summary>
                      
                      <p><strong>What Happens on the Optitrack Station:</strong></p>
                      <p>
                          On the Optitrack station, a rigid body is created within the Motive app. This rigid body represents the drone or its tracking system. A script is then executed to track the current position of the rigid body in real-time. The script sends the position data through a UDP connection to the base station. The data sent includes:
                      </p>
                      <ul>
                          <li><b>x, y, z</b>: Position coordinates of the rigid body.</li>
                          <li><b>x, y, z, w</b>: Quaternion values representing the orientation of the rigid body.</li>
                      </ul>
                      <p>The UDP connection continuously transmits the position and orientation data from Optitrack to the base station for further processing.</p>
                  
                      <p><strong>What Happens on the BaseStation:</strong></p>
                      <p>
                          On the BaseStation, the system listens for the incoming UDP messages containing the position and orientation data. Upon receiving the data, it performs the following steps:
                      </p>
                      <ul>
                          <li>The system extracts the <b>x, y, z</b> position and <b>x, y, z, w</b> quaternion orientation values from the UDP message.</li>
                          <li>The system then converts these values into a ROS <code>PoseStamped</code> message format, which is compatible with ROS2 for further processing.</li>
                          <li>The pose is also transformed to set a desired origin or reference frame, ensuring that the position data aligns with the control and simulation systems.</li>
                          <li>Additionally, a transformation is published, allowing other nodes in the ROS ecosystem to subscribe to and use the pose and orientation data for further control or monitoring purposes.</li>
                      </ul>
                      <p>This process allows the base station to track and control the position of the drone based on the data received from Optitrack, providing real-time feedback for control loop adjustments.</p>
                  
                  </details>
                  
                  <details>
                    <summary style="font-size: 1.25em; font-weight: bold;">ROS Control Loop</summary>
                    <ol><strong>Nodes</strong>
                      <li>Controller</li>
                      <li>Simulation</li>
                      <li>Optitrack</li>

                    </ol>
                    </details>

                    <h3>Controllers</h3>
                    <details>
                      <summary style="font-size: 1.25em; font-weight: bold;">PID Controller</summary>
                    <div>
                      <p>The system utilizes three PID loops for controlling the drone:</p>
                      <ul>
                          <li><b>Altitude (Z):</b> Maintains the desired height of the quadrotor.</li>
                          <li><b>Roll:</b> Stabilizes the quadrotor along the roll axis and controls its motion along the <b>Y-axis</b>.</li>
                          <li><b>Pitch:</b> Stabilizes the quadrotor along the pitch axis and controls its motion along the <b>X-axis</b>.</li>
                      </ul>
                  
                      <h5>PID for Altitude (Z)</h5>
                      <p>The altitude PID loop computes the error between the desired altitude and the current altitude. Based on this error, the PID controller calculates an output value, which determines the necessary adjustment in throttle.</p>
                      <p>The computed output is scaled and returned as a PWM value ranging from <b>1000</b> to <b>1950</b>. This value is used as the throttle command for the drone, ensuring it maintains or reaches the desired height.</p>
                  
                      <h5>PID for Roll and Pitch</h5>
                      <p>Separate PID loops for roll and pitch control the drone's stabilization along these axes and enable position control:</p>
                      <ul>
                          <li><b>Roll:</b> The roll PID adjusts the drone's angle to achieve the desired <b>Y-axis position</b>.</li>
                          <li><b>Pitch:</b> The pitch PID adjusts the drone's angle to achieve the desired <b>X-axis position</b>.</li>
                      </ul>
                      <p>The error between the desired and actual positions in the X and Y directions is translated into roll and pitch commands, respectively. The PID controllers generate output values, which are converted to PWM signals ranging from <b>1000</b> to <b>2000</b>.</p>
                  
                      <h5>General Behavior</h5>
                      <ul>
                          <li>The controllers integrate the error over time (integral term) to address steady-state errors.</li>
                          <li>They also consider the rate of change of the error (derivative term) to counteract overshooting and oscillations.</li>
                          <li>The roll and pitch outputs are constrained to ensure stability and fall within a physical limit (e.g., ±55 degrees for roll and pitch).</li>
                      </ul>
                  
                      <h5>Control Process</h5>
                      <p>During each control loop:</p>
                      <ul>
                          <li>The altitude PID adjusts the throttle to maintain or achieve the desired height.</li>
                          <li>The roll PID modifies the roll command to control the Y position of the drone.</li>
                          <li>The pitch PID modifies the pitch command to control the X position of the drone.</li>
                      </ul>
                  
                      <h5>Return Values</h5>
                      <p>The key output of each PID loop is a <b>PWM signal</b> (Pulse Width Modulation), scaled and mapped to the range suitable for the drone's flight controller. These PWM signals directly drive the motors and affect the drone's movement and stability.</p>
                  
                    </div>
                  </details>
                    <p style="font-size: 1.25em; font-weight: bold;">Minimum-snap</p>
                    <ul>
                      <details>
                        <summary><b>Minimum-Snap Trajectory Generator</b></summary>
                        <p>This implementation of the trajectory generator is based on the seminal work by Vijay Kumar and colleagues, specifically their paper on <b>Minimum snap trajectory generation and control for quadrotors</b>. It computes smooth, dynamically feasible trajectories for a quadcopter by minimizing snap (the fourth derivative of position) while satisfying boundary conditions for position, velocity, acceleration, and jerk.</p>
                    
                        <h5>Overview</h5>
                        <p>The generator calculates polynomial trajectories for the quadcopter's six degrees of freedom: <b>x, y, z (position), roll, pitch, and yaw</b>. The trajectory is expressed as a seventh-order polynomial, chosen for its ability to satisfy constraints on position, velocity, acceleration, and jerk at both the start and end of the trajectory.</p>
                    
                        <h5>Equations</h5>
                        <p>The polynomial trajectory for a single axis is given by:</p>
                        <p style="text-align: center;">\( x(t) = a_7 t^7 + a_6 t^6 + a_5 t^5 + a_4 t^4 + a_3 t^3 + a_2 t^2 + a_1 t + a_0 \)</p>
                        <p>Where \( x(t) \) represents the position at time \( t \), and the coefficients \( a_0, a_1, \ldots, a_7 \) are determined to minimize the snap (fourth derivative of position):</p>
                        <p style="text-align: center;">\( \text{Snap} = \frac{d^4x(t)}{dt^4} \).</p>
                    
                        <h5>Boundary Conditions</h5>
                        <p>The trajectory ensures continuity and smoothness by satisfying the following constraints at the start (\( t = 0 \)) and end (\( t = T \)) of the trajectory:</p>
                        <ul>
                            <li>Position: \( x(0), x(T) \)</li>
                            <li>Velocity: \( \dot{x}(0), \dot{x}(T) = 0 \)</li>
                            <li>Acceleration: \( \ddot{x}(0), \ddot{x}(T) = 0 \)</li>
                            <li>Jerk: \( \dddot{x}(0), \dddot{x}(T) = 0 \)</li>
                        </ul>
                    
                        <h5>Matrix Formulation</h5>
                        <p>The coefficients \( a_0 \) to \( a_7 \) are computed by solving the linear system:</p>
                        <p style="text-align: center;">\( A \cdot \mathbf{c} = \mathbf{B} \)</p>
                        <p>Where:</p>
                        <ul>
                            <li>\( A \): The boundary condition matrix constructed using polynomial terms and their derivatives for the start and end times.</li>
                            <li>\( \mathbf{B} \): A vector containing the boundary conditions for position, velocity, acceleration, and jerk.</li>
                            <li>\( \mathbf{c} \): The vector of polynomial coefficients to be solved.</li>
                        </ul>
                    
                        <h5>Trajectory Evaluation</h5>
                        <p>The trajectory can be evaluated for position, velocity, acceleration, or jerk at any time \( t \) by taking successive derivatives of the polynomial:</p>
                        <ul>
                            <li>Position: \( x(t) \)</li>
                            <li>Velocity: \( \dot{x}(t) = 7a_7 t^6 + 6a_6 t^5 + \ldots + a_1 \)</li>
                            <li>Acceleration: \( \ddot{x}(t) = 42a_7 t^5 + 30a_6 t^4 + \ldots \)</li>
                            <li>Jerk: \( \dddot{x}(t) = 210a_7 t^4 + 120a_6 t^3 + \ldots \)</li>
                        </ul>
                    
                        <h5>Key Features</h5>
                        <ul>
                            <li><b>Optimal Smoothness:</b> By minimizing snap, the trajectory ensures smooth and efficient motion with minimal actuator effort.</li>
                            <li><b>Flexibility:</b> The generator can handle arbitrary boundary conditions for all six degrees of freedom.</li>
                            <li><b>Real-Time Update:</b> Coefficients can be recomputed dynamically if the starting conditions change mid-flight.</li>
                        </ul>
                    
                        <h5>Implementation Notes</h5>
                        <p>The generator constructs individual trajectories for each degree of freedom. The coefficients for each trajectory are precomputed using matrix inversion. At runtime, the polynomial is evaluated at the desired time points to obtain position, velocity, acceleration, or jerk.</p>
                    
                        <h5>Relevance</h5>
                        <p>This approach is crucial for precise quadrotor maneuvers, especially in scenarios requiring high-speed, aggressive, or dynamic flight. The implementation is directly inspired by Vijay Kumar's work, which has been widely adopted for trajectory planning in autonomous drones.</p>
                    </details>
                    




                    <details>
                      <summary><b>Controller Design</b></summary>
                      <p>
                          To enable the quadrotor to follow specified trajectories \( \sigma_T(t) = [r_T(t)^T, \psi_T(t)]^T \), the controller uses the following components:
                      </p><h5>Position and Velocity Errors</h5>
                          <p>
                              The errors on position and velocity are defined as:
                              \[
                              e_p = r - r_T, \quad e_v = \dot{r} - \dot{r}_T
                              \]
                          </p>
                          
                          <h5>Desired Force Vector</h5>
                          <p>
                              The desired force vector for the controller and the desired body frame z-axis are calculated as:
                              \[
                              F_{des} = -K_p e_p - K_v e_v + mg \mathbf{x}_W + m \ddot{r}_T
                              \]
                              Here, \( K_p \) and \( K_v \) are positive definite gain matrices. We assume \( \|F_{des}\| \neq 0 \).
                          </p>
                      <h5>Total Thrust</h5>
                          <p>
                              The desired force is projected onto the actual body frame z-axis to compute the total thrust:
                              \[
                              u_1 = F_{des} \cdot z_B
                              \]
                          </p>
                      <h5>Desired Orientation</h5>
                          <p>
                              To determine the desired orientation:
                              <ul>
                                  <li>The desired body frame z-axis:
                                      \[
                                      z_{B, des} = \frac{F_{des}}{\|F_{des}\|}
                                      \]
                                  </li>
                                  <li>Using the specified yaw angle \( \psi_T(t) \), the desired body frame x-axis and y-axis are:
                                      \[
                                      x_{C, des} = [\cos\psi_T, \sin\psi_T, 0]^T
                                      \]
                                      \[
                                      y_{B, des} = \frac{z_{B, des} \times x_{C, des}}{\|z_{B, des} \times x_{C, des}\|}, \quad x_{B, des} = y_{B, des} \times z_{B, des}
                                      \]
                                  </li>
                              </ul>
                              The desired rotation matrix is then:
                              \[
                              R_{des} = [x_{B, des}, y_{B, des}, z_{B, des}]
                              \]
                          </p>
                      <h5>Orientation and Angular Velocity Errors</h5>
                          <p>
                              The orientation error is defined as:
                              \[
                              e_R = \frac{1}{2}(R_{des}^T W R_B - W R_B^T R_{des})^\vee
                              \]
                              where \( \vee \) represents the vee map converting elements of \( \text{so}(3) \) to \( \mathbb{R}^3 \).
                          </p>
                          <p>
                              The angular velocity error is:
                              \[
                              e_\omega = \mathbf{B}[\omega_{BW}] - \mathbf{B}[\omega_{BW, T}]
                              \]
                          </p>
                      <h5>Desired Moments</h5>
                          <p>
                              The desired moments and the remaining three inputs are computed as:
                              \[
                              [u_2, u_3, u_4]^T = -K_R e_R - K_\omega e_\omega
                              \]
                              where \( K_R \) and \( K_\omega \) are diagonal gain matrices, allowing unique gains for roll, pitch, and yaw tracking.
                          </p>
                  </details>
                  
                    </ul>
                 
                    <h3>Results</h3>
                    <h4><b>PID sim</b></h4>
                    <h4><b>PID hardware</b></h4>
                    <h4><b>Minimum-snap sim</b></h4>
                    <h4><b>Minimum-snap hardware</b></h4>
                    
                <div class="col mb-md-0 text-center" data-aos="fade-up">
                  <p><a href="https://github.com/aawizard/quad_ws" class="readmore">Github</a></p>
                </div>
            </div>
            

        </div>
    </section>

</main><!-- End #main -->


  <!-- ======= Footer ======= -->
  <footer class="footer" role="contentinfo">
    <div class="container">
      <div class="row">

        <div class=" social text-center mx-auto">
          
          <a href="https://github.com/aawizard"><span class="bi bi-github"></span></a>
          <a href="mailto:aawizard@u.northwestern.edu"><span class="bi bi-envelope"></span></a>
          <!-- <a href="#"><span class="bi bi-instagram"></span></a> -->
          <a href="https://www.linkedin.com/in/ananya-agarwal-0b60a3192/"><span class="bi bi-linkedin"></span></a>
        </div>
      </div>
    </div>
  </footer>

  <a href="#" class="back-to-top d-flex align-items-center justify-content-center"><i class="bi bi-arrow-up-short"></i></a>

  <!-- Vendor JS Files -->
  <script src="../assets/vendor/aos/aos.js"></script>
  <script src="../assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="../assets/vendor/isotope-layout/isotope.pkgd.min.js"></script>
  <script src="../assets/vendor/swiper/swiper-bundle.min.js"></script>
  <script src="../assets/vendor/php-email-form/validate.js"></script>

  <!-- Template Main JS File -->
  <script src="../assets/js/main.js"></script>

</body>

</html>