<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">

  <title>Ananya-Portfolio</title>
    <meta content="" name="description">
  <meta content="" name="keywords">

  <!-- Favicons -->
  <!-- <link href="assets/img/favicon.png" rel="icon"> -->
  <!-- <link href="assets/img/apple-touch-icon.png" rel="apple-touch-icon"> -->

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=https://fonts.googleapis.com/css?family=Inconsolata:400,500,600,700|Raleway:400,400i,500,500i,600,600i,700,700i" rel="stylesheet">

  <!-- Vendor CSS Files -->
  <link href="../assets/vendor/aos/aos.css" rel="stylesheet">
  <link href="../assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="../assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="../assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">

  <!-- Template Main CSS File -->
  <link href="../assets/css/style.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <!-- =======================================================
  * Template Name: MyPortfolio
  * Updated: Sep 18 2023 with Bootstrap v5.3.2
  * Template URL: https://bootstrapmade.com/myportfolio-bootstrap-portfolio-website-template/
  * Author: BootstrapMade.com
  * License: https://bootstrapmade.com/license/
  ======================================================== -->
</head>

<body>
  <nav class="navbar navbar-light custom-navbar">
    <div class="container">
      <a class="navbar-brand" href="../index.html">Ananya Agarwal</a>
      <div class="row-md-1">
      <a href="../index.html">Projects</a>
      <a href="../about.html">About Me</a>
      <a href="../resume.html">Resume</a>
      <a href="../contact.html">Contact</a>
        <span></span>
      </a>
    </div>
  </nav>


  <main id="main">

    <section class="section pb-5">
        <div class="container">
            <div class="row  align-items-end">
                <div class="col-md-6 text-center mx-auto" data-aos="fade-up">
                    <h2> Minimum snap drone control with mathematical simulation</h2>
                    
                </div>
            </div>

            <div class="col discription">
                <div class="col mb-md-0 " data-aos="fade-up">
                    <h3>Brief Overview</h3>
                    <p >The objective is to achieve precise and efficient quadrotor movement from point A to B in the minimum possible time. The project involves developing a mathematical simulation for a given hardware design, replicating its controls, creating a ROS-based control loop with a PID controller, and implementing a minimum snap trajectory generator and trajectory controller.</p>

                    <h3>Video demo</h3>
                    <!-- <p class="text-center"><iframe width="560" height="315" src="https://www.youtube.com/embed/PGhHzJX8ALY?si=nYK3LCMetfZ7e3XH" frameborder="0" allowfullscreen></iframe></p> -->
                     TODO
                    <h3>Hardware setup</h3>
                    <p>
                        The quadrotor hardware includes a <b>Betaflight flight controller</b>, a <b>Raspberry Pi 0</b> for processing, and <b>1103 brushless motors</b> with KV ratings of 8000 to 15000 RPM/V. The controller takes inputs such as <b>roll, pitch, yaw (1050-1900 range)</b>, and <b>throttle (1000-1900 range)</b>.
                      </p>
                      
                      <p>
                        The drone's position is independently tracked using <b>OptiTrack</b>, providing precise positional data for validation and control loop optimization.
                      </p>
                      
                    <p class="text-center"><img src="../assets/img/drone_hardware.jpeg" alt="Image" class="img-fluid mx-auto d-block "  width="360" height="215"></p>
                    <p></p>
                    <h3>Software setup</h3>
                    <p>
                        The simulation is developed in <b>Python</b> and <b>ROS2</b> visualizing in <b>Rviz</b>. The simulation includes a quadrotor model with a <b>minimum snap trajectory generator</b> and a <b>trajectory controller</b>.
                      </p>
                      
                      <p>
                        The control loop is implemented in <b>ROS</b> using <b>Python</b> and <b>rospy</b>. The control loop includes a <b>PID controller</b> or <b>Trajectory controller</b> for roll, pitch, yaw, and throttle.
                      </p>
                    <!-- space of 1 line -->
                    <p></p>    
                    <details>
                    <summary  style="font-size: 1.25em; font-weight: bold;">Simulation</summary>
                    
                      <div>
                       
                        <p>
                          The control inputs provided to the quadrotor are as follows:
                        </p>
                        <ul>
                          <li><b>Roll, Pitch, and Yaw:</b> Input values range from 1050 to 1900. A value of 1500 corresponds to the neutral position. Roll and pitch inputs are scaled to absolute angles based on the maximum tilt angle set in the Betaflight flight controller.</li>
                          <li><b>Throttle:</b> Input values range from 1000 to 1900, where 1000 represents 0% thrust and 1900 corresponds to 100% thrust.</li>
                        </ul>
                    
                        <h5><b>Control and Simulation Process:</b></h5>
                        <ol>
                          <li><b>PWM to Angle Conversion:</b> Roll and pitch targets are calculated using the formula:
                            <p>
                              \[
                              \text{Target Angle} = \left( \frac{\text{Input} - 1050}{900} \times 110 \right) - 55
                              \]
                            </p>
                          </li>
                          <li><b>Thrust Calculation:</b> The thrust is calculated as:
                            <p>
                              \[
                              \text{Thrust} = \frac{\text{Input} - 1000}{1000} \times \text{Max Thrust}
                              \]
                            </p>
                          </li>
                          <li><b>PID Control:</b> PID controllers are implemented for roll and pitch stabilization. The error is the difference between the target angle and the current angle:
                            <p>
                              \[
                              \text{Error}_{\text{roll}} = \text{Target Roll (rad)} - \text{Current Roll (rad)}
                              \]
                              \[
                              \text{Error}_{\text{pitch}} = \text{Target Pitch (rad)} - \text{Current Pitch (rad)}
                              \]
                            </p>
                            The control effort is updated using the PID formula:
                            <p>
                              \[
                              \text{Control Effort} = K_p \times \text{Error} + K_i \times \int \text{Error} \, dt + K_d \times \frac{d(\text{Error})}{dt}
                              \]
                            </p>
                          </li>
                          <li><b>Thrust Transformation:</b> The thrust in the body frame is converted to the world frame using the rotation matrix:
                            <p>
                              \[
                              \mathbf{Thrust}_{\text{GF}} = \mathbf{R}_{\text{BF→GF}} \times \begin{bmatrix} 0 \\ 0 \\ \text{Thrust} \end{bmatrix}
                              \]
                            </p>
                            Where \(\mathbf{R}_{\text{BF→GF}}\) is the rotation matrix derived from the roll, pitch, and yaw angles.
                          </li>
                          <li><b>Position Updates:</b> The acceleration in each axis is computed, and velocities and positions are updated:
                            <p>
                              \[
                              \ddot{z} = \frac{\text{Thrust}_{z, \text{GF}}}{m} - g
                              \]
                              \[
                              \ddot{x} = -\frac{\text{Thrust}_{x, \text{GF}}}{m}, \quad \ddot{y} = -\frac{\text{Thrust}_{y, \text{GF}}}{m}
                              \]
                              \[
                              \dot{x} = \dot{x} + \ddot{x} \cdot dt, \quad x = x + \dot{x} \cdot dt
                              \]
                            </p>
                            Similar equations apply for \(y\) and \(z\).
                          </li>
                        </ol>
                    
                        <h5><b>Key Considerations:</b></h5>
                        <ul>
                          <li><b>Ground Constraint:</b> If \(z < 0\), the quadrotor is grounded, and all velocities are set to zero.</li>
                          <li><b>Random Perturbations:</b> Small random variations are introduced to \(p\) and \(q\) to simulate real-world disturbances.</li>
                        </ul>
                        <h5>Drone Marker Visualization</h5>
                        <p>
                          The simulation includes a visualization of the drone as a marker in Rviz. While the marker does not accurately represent the physical dimensions of the drone, it serves as a visual aid to demonstrate its position and orientation during the simulation. Below is a snapshot of the visualization:
                        </p>
                        <p class="text-center">
                          <img src="../assets/img/drone_visualization.png" alt="Drone Marker Visualization" class="img-fluid mx-auto d-block" width="360" height="215">
                        </p>

                      </div>
                    </details>
                                       
                    <details>
                      <summary style="font-size: 1.25em; font-weight: bold;">Controller On Board</summary>
                      <div style="margin-left: 20px;">
                        <h5>Raspberry Pi Zero Communication</h5>
                        <p>
                          The Raspberry Pi Zero serves as the intermediary between the control commands and the Betaflight flight controller on the quadrotor. It communicates with the base station computer through a UDP connection, running at a frequency of 100 Hz. The control messages it sends include throttle, roll, pitch, yaw, arm/disarm status, and flight mode.
                        </p>
                        <h5>Control Commands Sent to the Raspberry Pi</h5>
                        <ul>
                          <li><b>Throttle</b>: The throttle value to control the motor speed.</li>
                          <li><b>Roll</b>: The roll command to control the drone's roll angle.</li>
                          <li><b>Pitch</b>: The pitch command to control the drone's pitch angle.</li>
                          <li><b>Yaw</b>: The yaw command to control the drone's yaw angle.</li>
                          <li><b>Aux1 (Arm/Disarm)</b>: Controls the arm/disarm state of the drone.
                            <ul>
                              <li><b>1000</b>: Disarm</li>
                              <li><b>1800</b>: Arm</li>
                            </ul>
                          </li>
                          <li><b>Aux2 (Mode)</b>: Controls the flight mode of the drone. There are two modes:
                            <ul>
                              <li><b>Angle Mode</b>: Stabilized flight mode, where the drone tries to maintain a fixed angle.</li>
                              <li><b>Horizon Mode</b>: A hybrid mode between manual and stabilized, with limited angle control.</li>
                            </ul>
                          </li>
                        </ul>
                        
                        <h5>Communication with Betaflight Controller</h5>
                        <p>
                          The Raspberry Pi uses the <b>yamspy</b> library to communicate with the Betaflight controller board. The communication is based on the MSP (Multiwii Serial Protocol) to send control commands to the flight controller.
                        </p>
                        
                        <h5>Control Node</h5>
                        <p>
                          The drone control node subscribes to the <code>/quad_ctrl</code> topic and receives the control commands. It then sends the commands to the Raspberry Pi through UDP, ensuring smooth control of the drone.
                        </p>
                      </div>
                    </details>
                    
                    <details>
                      <summary style="font-size: 1.25em; font-weight: bold;">Communication with Optitrack</summary>
                      
                      <p><strong>What Happens on the Optitrack Station:</strong></p>
                      <p>
                          On the Optitrack station, a rigid body is created within the Motive app. This rigid body represents the drone or its tracking system. A script is then executed to track the current position of the rigid body in real-time. The script sends the position data through a UDP connection to the base station. The data sent includes:
                      </p>
                      <ul>
                          <li><b>x, y, z</b>: Position coordinates of the rigid body.</li>
                          <li><b>x, y, z, w</b>: Quaternion values representing the orientation of the rigid body.</li>
                      </ul>
                      <p>The UDP connection continuously transmits the position and orientation data from Optitrack to the base station for further processing.</p>
                  
                      <p><strong>What Happens on the BaseStation:</strong></p>
                      <p>
                          On the BaseStation, the system listens for the incoming UDP messages containing the position and orientation data. Upon receiving the data, it performs the following steps:
                      </p>
                      <ul>
                          <li>The system extracts the <b>x, y, z</b> position and <b>x, y, z, w</b> quaternion orientation values from the UDP message.</li>
                          <li>The system then converts these values into a ROS <code>PoseStamped</code> message format, which is compatible with ROS2 for further processing.</li>
                          <li>The pose is also transformed to set a desired origin or reference frame, ensuring that the position data aligns with the control and simulation systems.</li>
                          <li>Additionally, a transformation is published, allowing other nodes in the ROS ecosystem to subscribe to and use the pose and orientation data for further control or monitoring purposes.</li>
                      </ul>
                      <p>This process allows the base station to track and control the position of the drone based on the data received from Optitrack, providing real-time feedback for control loop adjustments.</p>
                  
                  </details>
                  
                  <details>
                    <summary style="font-size: 1.25em; font-weight: bold;">ROS Control Loop</summary>
                    <p>
                      The drone, whether in simulation or real-world scenarios, can be controlled in three distinct ways: 
                      <strong>Joystick control</strong>, <strong>PID controller</strong>, or <strong>Minimum Snap Trajectory controller</strong>. 
                      These methods allow flexibility depending on the task and environment. The control loop adapts seamlessly 
                      between user inputs, algorithm-based adjustments, or predefined trajectory commands, ensuring efficient and 
                      precise control of the drone.
                    </p>
                    <div style="text-align: center; margin: 20px 0;">
                      <img src="joystick_control_loop.png" alt="Joystick Control Loop" style="max-width: 80%; height: auto;">
                      <figcaption style="font-size: 0.9em; margin-top: 5px;">Figure 1: Joystick-based control loop</figcaption>
                    </div>
                    <div style="text-align: center; margin: 20px 0;">
                      <img src="pid_control_loop.png" alt="PID Controller Control Loop" style="max-width: 80%; height: auto;">
                      <figcaption style="font-size: 0.9em; margin-top: 5px;">Figure 2: PID Controller-based control loop</figcaption>
                    </div>
                    <div style="text-align: center; margin: 20px 0;">
                      <img src="traj_control_loop.png" alt="Minimum Snap Trajectory Control Loop" style="max-width: 80%; height: auto;">
                      <figcaption style="font-size: 0.9em; margin-top: 5px;">Figure 3: Minimum Snap Trajectory-based control loop</figcaption>
                    </div>
                    <ol><strong>Nodes</strong>
                      <details>
                        <summary style="font-weight: bold;">Joystick Node</summary>
                        <p>
                          The <strong>Joystick Node</strong> enables interaction between the user and the drone by processing input from a joystick. 
                          It translates joystick commands into drone control messages and publishes these commands to a topic for further use by 
                          other nodes in the control system.
                        </p>
                        <p>
                          <strong>Subscriptions:</strong>
                          <ul>
                            <li><em>No subscriptions.</em></li>
                          </ul>
                          <strong>Publications:</strong>
                          <ul>
                            <li><code>/quad_ctrl</code>: Publishes joystick commands as a <code>QuadCmd</code> message containing roll, pitch, throttle, yaw, armed status, and mode.</li>
                          </ul>
                        </p>
                        <p>
                          <strong>Communication with the Joystick:</strong>
                          <ul>
                            <li>Reads joystick inputs using a compatible library, capturing the state of axes and buttons.</li>
                            <li>Maps joystick inputs to drone control commands, such as roll, pitch, throttle, and yaw.</li>
                            <li>Includes functionality for arming the drone and switching modes based on button presses.</li>
                          </ul>
                        </p>
                        <p>
                          <strong>Key Features:</strong>
                          <ul>
                            <li>Maps joystick axes to roll, pitch, throttle, and yaw values, ensuring precise user control over the drone's movements.</li>
                            <li>Processes button presses to toggle the drone's armed state and change flight modes.</li>
                            <li>Publishes user commands to the <code>/quad_ctrl</code> topic in real time, enabling other nodes to execute the desired actions.</li>
                            <li>Implements a safety mechanism by monitoring the state of the armed flag to ensure safe operation.</li>
                          </ul>
                        </p>
                        <p>
                          <strong>Node Workflow:</strong>
                          <ol>
                            <li>Starts by initializing the joystick interface and configuring input mappings for axes and buttons.</li>
                            <li>Continuously reads input data from the joystick at a predefined rate.</li>
                            <li>Processes the joystick data to compute control values for roll, pitch, throttle, and yaw.</li>
                            <li>Determines the drone's armed state and flight mode based on specific button presses.</li>
                            <li>Publishes the computed control commands to the <code>/quad_ctrl</code> topic in the form of a <code>QuadCmd</code> message.</li>
                          </ol>
                        </p>
                      </details>
                      

                      <details>
                        <summary style="font-weight: bold;">Drone Control Node</summary>
                        <p>
                          The <strong>Drone Control Node</strong> is responsible for controlling the drone's behavior based on received control commands. 
                          It subscribes to relevant topics that provide the current state of the drone, processes these inputs, and publishes 
                          commands to actuate the drone's motors, adjusting its flight dynamics accordingly.
                        </p>
                        <p>
                          <strong>Subscriptions:</strong>
                          <ul>
                            <li><code>/quad_pose</code>: Subscribes to the drone's pose (position and orientation) using a <code>PoseStamped</code> message.</li>
                            <li><code>/quad_ctrl</code>: Subscribes to control commands for the drone (roll, pitch, throttle, yaw, armed state, mode) 
                                using a <code>QuadCmd</code> message to initiate control actions.</li>
                          </ul>
                          <strong>Publications:</strong>
                          <ul>
                            <li><code>/drone_control_feedback</code>: Publishes feedback on the drone's current control status, position, and orientation.</li>
                          </ul>
                        </p>
                        <p>
                          <strong>Communication with Other Nodes:</strong>
                          <ul>
                            <li>Receives control commands from the joystick node through the <code>/quad_ctrl</code> topic to determine the desired drone 
                                movements (e.g., roll, pitch, throttle, yaw, armed status, and mode).</li>
                            <li>Receives the current pose of the drone from the <code>/quad_pose</code> topic to assess the drone's position and orientation.</li>
                            <li>Processes both control and pose data to compute necessary actions for motor commands and flight adjustments.</li>
                            <li>Publishes feedback about the drone's current state to the <code>/drone_control_feedback</code> topic for monitoring purposes.</li>
                          </ul>
                        </p>
                        <p>
                          <strong>Key Features:</strong>
                          <ul>
                            <li>Receives control input (roll, pitch, throttle, yaw) and applies the necessary transformations to actuate the drone’s flight.</li>
                            <li>Monitors the armed state and mode of the drone to ensure it responds only when it is safe and in the correct mode.</li>
                            <li>Uses PID or other control strategies to smoothen and stabilize the drone’s movements based on current pose and desired commands.</li>
                            <li>Provides real-time feedback to other systems about the drone's position, orientation, and control status.</li>
                          </ul>
                        </p>
                        <p>
                          <strong>Node Workflow:</strong>
                          <ol>
                            <li>Subscribes to the <code>/quad_pose</code> topic to get the current pose (position and orientation) of the drone.</li>
                            <li>Subscribes to the <code>/quad_ctrl</code> topic to receive control commands for roll, pitch, throttle, yaw, and the armed status.</li>
                            <li>Based on the control commands, adjusts the motor outputs to achieve the desired flight dynamics (e.g., stabilize pitch, roll, and yaw).</li>
                            <li>Applies a control algorithm (e.g., PID) to minimize error between the desired and actual states (e.g., position and orientation).</li>
                            <li>Publishes feedback about the drone's status (current position, orientation, etc.) on the <code>/drone_control_feedback</code> topic for monitoring.</li>
                          </ol>
                        </p>
                      </details>
                      
                      <details>
                        <summary style="font-weight: bold;">Quad Listener Node</summary>
                        <p>
                          The <strong>Quad Listener Node</strong> facilitates communication between the drone's position tracking system 
                          (OptiTrack) and the ROS environment. It receives UDP packets containing the drone's position and orientation data, 
                          applies necessary transformations to correct offsets, and publishes the corrected pose to the ROS network.
                        </p>
                        <p>
                          <strong>Subscriptions:</strong>
                          <ul>
                            <li><em>No subscriptions.</em></li>
                          </ul>
                          <strong>Publications:</strong>
                          <ul>
                            <li><code>/quad_pose</code>: Publishes the corrected position and orientation of the drone as a <code>PoseStamped</code> message.</li>
                          </ul>
                        </p>
                        <p>
                          <strong>Communication with OptiTrack:</strong>
                          <ul>
                            <li>Uses a UDP socket to receive real-time tracking data from OptiTrack. The data includes the drone's position (x, y, z) and orientation (quaternion qx, qy, qz, qw).</li>
                            <li>Processes the received data to remove offsets specific to each drone ("bird") based on parameters defined in a YAML file.</li>
                            <li>Corrects the received position and orientation using transformation matrices that adjust for the drone's predefined offsets in both position and orientation.</li>
                          </ul>
                        </p>
                        <p>
                          <strong>TF Broadcasting:</strong>
                          <ul>
                            <li>Broadcasts a transform named <code>drone</code> relative to the <code>map</code> frame, providing real-time positional and orientation updates of the drone in the ROS TF tree.</li>
                            <li>The transform is continuously updated at 100Hz, ensuring smooth and accurate representation of the drone's pose in the world frame.</li>
                          </ul>
                        </p>
                        <p>
                          <strong>Key Features:</strong>
                          <ul>
                            <li>Loads drone-specific position and orientation offsets from a YAML file.</li>
                            <li>Applies mathematical transformations to adjust the received pose data, ensuring that the published pose accurately reflects the drone's corrected position and orientation in the world frame.</li>
                            <li>Handles exceptions such as missing data or invalid configurations, ensuring robust communication with the tracking system.</li>
                          </ul>
                        </p>
                        <p>
                          <strong>Node Workflow:</strong>
                          <ol>
                            <li>Starts a UDP server to listen for incoming tracking data.</li>
                            <li>Loads bird-specific offsets from the YAML file and verifies their correctness.</li>
                            <li>Processes incoming UDP messages to extract positional and orientation data.</li>
                            <li>Applies the offset transformations using a combination of translation and rotation matrices.</li>
                            <li>Publishes the corrected pose to the <code>/quad_pose</code> topic.</li>
                            <li>Broadcasts the corrected pose as a transform in the TF tree, enabling other nodes to access real-time drone position and orientation information.</li>
                          </ol>
                        </p>
                      </details>
                      
                      <details>
                        <summary style="font-weight: bold;">QuadSim Node</summary>
                        <p>
                          The <strong>QuadSim Node</strong> simulates the behavior of a quadrotor drone by processing control inputs and updating the drone's pose 
                          (position and orientation) over time. It interfaces with a quadrotor model to compute the drone's state based on the control commands, 
                          publishes the updated pose, and visualizes the drone's parts using markers.
                        </p>
                        <p>
                          <strong>Subscriptions:</strong>
                          <ul>
                            <li><code>/quad_ctrl</code>: Subscribes to control commands for the drone (throttle, roll, pitch, yaw, armed state) using a <code>QuadCmd</code> message.</li>
                          </ul>
                          <strong>Publications:</strong>
                          <ul>
                            <li><code>/quad_pose</code>: Publishes the drone's updated pose (position and orientation) as a <code>PoseStamped</code> message.</li>
                            <li><code>visualization_marker_array</code>: Publishes a visualization of the drone's parts using a <code>MarkerArray</code> message.</li>
                            <li><code>/tf</code>: Publishes the transform between the "map" and "base_link" frames of the drone.</li>
                          </ul>
                        </p>
                        <p>
                          <strong>Communication with Other Nodes:</strong>
                          <ul>
                            <li>Receives control commands from the <code>/quad_ctrl</code> topic, including throttle, roll, pitch, yaw, and armed state.</li>
                            <li>Uses the quadrotor model to compute the new state of the drone based on these control inputs.</li>
                            <li>Publishes the drone's current pose to the <code>/quad_pose</code> topic.</li>
                            <li>Publishes markers representing the drone's parts and the drone's current state for visualization in RViz.</li>
                            <li>Publishes a transform (TF) to define the position and orientation of the drone in the "map" frame.</li>
                          </ul>
                        </p>
                        <p>
                          <strong>Key Features:</strong>
                          <ul>
                            <li>Simulates the behavior of a quadrotor drone based on control inputs (throttle, roll, pitch, yaw) from a <code>QuadCmd</code> message.</li>
                            <li>Converts the drone's position and orientation from Euler angles to quaternion format for consistency with ROS conventions.</li>
                            <li>Visualizes the drone's body parts (e.g., arms, motors) using RViz markers.</li>
                            <li>Calculates the new state of the drone (position, orientation) based on the quadrotor dynamics and control inputs.</li>
                            <li>Publishes the updated pose and transform data for external systems or visualization.</li>
                          </ul>
                        </p>
                        <p>
                          <strong>Node Workflow:</strong>
                          <ol>
                            <li>The node initializes parameters such as initial position, frame ID, and sets up communication channels (subscription and publication).</li>
                            <li>Subscribes to the <code>/quad_ctrl</code> topic to receive control commands (throttle, roll, pitch, yaw, armed state).</li>
                            <li>Uses the quadrotor model (in the <code>quadrotor</code> class) to compute the new drone state based on the control inputs.</li>
                            <li>Converts Euler angles (roll, pitch, yaw) into a quaternion for proper ROS integration.</li>
                            <li>Publishes the drone's updated pose (position and orientation) to the <code>/quad_pose</code> topic.</li>
                            <li>Publishes the transform between the "map" and "base_link" frames to the <code>/tf</code> topic for accurate positioning in 3D space.</li>
                            <li>Generates a visualization of the drone's body using <code>MarkerArray</code> messages, displaying parts such as arms and motors in RViz.</li>
                          </ol>
                        </p>
                      </details>
                      
                      <details>
                        <summary style="font-weight: bold;">Controller PID Node</summary>
                        <p><strong>Node Overview:</strong></p>
                        <p>
                          The <code>Controller_pid</code> node controls the quadcopter's position using PID controllers for altitude, roll, pitch, and yaw. It subscribes to the quadcopter's current position and publishes control commands to adjust its position toward a desired target in 3D space.
                        </p>
                      
                        <p><strong>Key Features:</strong></p>
                        <ul>
                          <li>PID control for altitude (Z axis), roll and pitch (X and Y axes), and yaw adjustment.</li>
                          <li>Real-time path tracking by publishing the quadcopter’s actual position over time.</li>
                          <li>Customizable desired position parameters for dynamic control.</li>
                          <li>Support for both simulation and real drone with different PID gain configurations.</li>
                          <li>Automatic arming of the drone when certain conditions are met during operation.</li>
                        </ul>
                      
                        <p><strong>Node Workflow:</strong></p>
                        <ol>
                          <li>The node initializes and fetches parameters for the desired position and mode (real drone or simulation).</li>
                          <li>Based on the mode (simulation or real), appropriate PID controller gains for altitude, roll, pitch, and yaw are configured.</li>
                          <li>The node subscribes to the <code>quad_pose</code> topic to receive the current position of the quadcopter.</li>
                          <li>The <code>listener_callback</code> function updates the current position of the quadcopter whenever new data is received from the <code>quad_pose</code> topic.</li>
                          <li>In the <code>timer_callback</code> function, control commands (throttle, roll, pitch) are computed based on the difference between the current position and the desired position using the PID controllers.</li>
                          <li>When the flag condition is met, the node arms the drone and publishes control commands to the <code>quad_ctrl</code> topic.</li>
                          <li>The node also continuously publishes the actual position path to the <code>actual_path</code> topic for visualization.</li>
                        </ol>
                      
                        <p><strong>Subscribers:</strong></p>
                        <ul>
                          <li><code>quad_pose</code> - Subscribes to the current position of the quadcopter (message type: <code>PoseStamped</code>).</li>
                        </ul>
                      
                        <p><strong>Publishers:</strong></p>
                        <ul>
                          <li><code>quad_ctrl</code> - Publishes control commands (throttle, roll, pitch, yaw) to the quadcopter (message type: <code>QuadCmd</code>).</li>
                          <li><code>actual_path</code> - Publishes the actual path of the quadcopter for visualization (message type: <code>Path</code>).</li>
                        </ul>
                      
                        <p><strong>Functions:</strong></p>
                        <ul>
                          <li><code>listener_callback</code> - Updates the current position of the quadcopter and appends the position to the actual path.</li>
                          <li><code>timer_callback</code> - Runs periodically to compute control commands based on position errors and publishes them to the <code>quad_ctrl</code> topic.</li>
                          <li><code>set_desired_position</code> - Allows updating the desired position dynamically.</li>
                        </ul>
                      </details>
                      
                      
                      
                      <details>
                        <summary>Controller Trajectory Node</summary>
                        <p><strong>Node Overview:</strong></p>
                        <p>
                          The <code>controller_traj</code> node manages the trajectory tracking of a quadcopter by using a trajectory controller and PID controllers for altitude, roll, and pitch. It tracks the position of the quadcopter, computes errors, and adjusts the control inputs (throttle, roll, pitch, yaw) to move the quadcopter toward a desired position.
                        </p>
                      
                        <p><strong>Key Features:</strong></p>
                        <ul>
                          <li>Trajectory tracking using a <code>TrajectoryController</code> for smooth path execution.</li>
                          <li>PID controllers for altitude, roll, and pitch stabilization.</li>
                          <li>Ability to control both simulation and real drone with customizable PID gains.</li>
                          <li>Publishing the quadcopter’s trajectory and actual position for visualization.</li>
                          <li>Automatic arming of the drone when it reaches a safe position and starts the trajectory.</li>
                        </ul>
                      
                        <p><strong>Node Workflow:</strong></p>
                        <ol>
                          <li>The node initializes parameters for the desired position and simulation mode (real drone or simulation).</li>
                          <li>It subscribes to the <code>quad_pose</code> topic to receive the current position and orientation of the quadcopter.</li>
                          <li>The <code>listener_callback</code> function updates the current position and sets up the trajectory controller if it's the first position.</li>
                          <li>In the <code>timer_callback</code> function, the node computes control commands based on the trajectory tracking and PID control outputs for altitude, roll, and pitch.</li>
                          <li>Control commands are published to the <code>quad_ctrl</code> topic for the quadcopter to follow.</li>
                          <li>The trajectory path and actual path are continuously published to the <code>traj_path</code> and <code>actual_path</code> topics for visualization.</li>
                        </ol>
                      
                        <p><strong>Subscribers:</strong></p>
                        <ul>
                          <li><code>quad_pose</code> - Subscribes to the current position of the quadcopter (message type: <code>PoseStamped</code>).</li>
                        </ul>
                      
                        <p><strong>Publishers:</strong></p>
                        <ul>
                          <li><code>quad_ctrl</code> - Publishes control commands (throttle, roll, pitch, yaw) to the quadcopter (message type: <code>QuadCmd</code>).</li>
                          <li><code>traj_path</code> - Publishes the desired trajectory path (message type: <code>Path</code>).</li>
                          <li><code>actual_path</code> - Publishes the actual path followed by the quadcopter (message type: <code>Path</code>).</li>
                        </ul>
                      
                        <p><strong>Functions:</strong></p>
                        <ul>
                          <li><code>listener_callback</code> - Updates the current position and sets up the trajectory controller if it's the first position.</li>
                          <li><code>timer_callback</code> - Runs periodically to compute and publish control commands based on trajectory tracking and PID control.</li>
                          <li><code>euler_to_quaternion</code> - Converts Euler angles (roll, pitch, yaw) to quaternion for orientation representation.</li>
                          <li><code>quaternion_to_euler</code> - Converts quaternion orientation to Euler angles (roll, pitch, yaw).</li>
                          <li><code>add_trajectory_point</code> - Adds a point to the desired trajectory path.</li>
                          <li><code>set_desired_position</code> - Allows dynamic updates to the desired target position.</li>
                        </ul>
                      </details>
                      
                      
                    </ol>
                  </details>

                    <h3>Controllers</h3>
                    <details>
                      <summary style="font-size: 1.25em; font-weight: bold;">PID Controller</summary>
                    <div>
                      <p>The system utilizes three PID loops for controlling the drone:</p>
                      <ul>
                          <li><b>Altitude (Z):</b> Maintains the desired height of the quadrotor.</li>
                          <li><b>Roll:</b> Stabilizes the quadrotor along the roll axis and controls its motion along the <b>Y-axis</b>.</li>
                          <li><b>Pitch:</b> Stabilizes the quadrotor along the pitch axis and controls its motion along the <b>X-axis</b>.</li>
                      </ul>
                  
                      <h5>PID for Altitude (Z)</h5>
                      <p>The altitude PID loop computes the error between the desired altitude and the current altitude. Based on this error, the PID controller calculates an output value, which determines the necessary adjustment in throttle.</p>
                      <p>The computed output is scaled and returned as a PWM value ranging from <b>1000</b> to <b>1950</b>. This value is used as the throttle command for the drone, ensuring it maintains or reaches the desired height.</p>
                  
                      <h5>PID for Roll and Pitch</h5>
                      <p>Separate PID loops for roll and pitch control the drone's stabilization along these axes and enable position control:</p>
                      <ul>
                          <li><b>Roll:</b> The roll PID adjusts the drone's angle to achieve the desired <b>Y-axis position</b>.</li>
                          <li><b>Pitch:</b> The pitch PID adjusts the drone's angle to achieve the desired <b>X-axis position</b>.</li>
                      </ul>
                      <p>The error between the desired and actual positions in the X and Y directions is translated into roll and pitch commands, respectively. The PID controllers generate output values, which are converted to PWM signals ranging from <b>1000</b> to <b>2000</b>.</p>
                  
                      <h5>General Behavior</h5>
                      <ul>
                          <li>The controllers integrate the error over time (integral term) to address steady-state errors.</li>
                          <li>They also consider the rate of change of the error (derivative term) to counteract overshooting and oscillations.</li>
                          <li>The roll and pitch outputs are constrained to ensure stability and fall within a physical limit (e.g., ±55 degrees for roll and pitch).</li>
                      </ul>
                  
                      <h5>Control Process</h5>
                      <p>During each control loop:</p>
                      <ul>
                          <li>The altitude PID adjusts the throttle to maintain or achieve the desired height.</li>
                          <li>The roll PID modifies the roll command to control the Y position of the drone.</li>
                          <li>The pitch PID modifies the pitch command to control the X position of the drone.</li>
                      </ul>
                  
                      <h5>Return Values</h5>
                      <p>The key output of each PID loop is a <b>PWM signal</b> (Pulse Width Modulation), scaled and mapped to the range suitable for the drone's flight controller. These PWM signals directly drive the motors and affect the drone's movement and stability.</p>
                  
                    </div>
                  </details>
                    <p style="font-size: 1.25em; font-weight: bold;">Minimum-snap</p>
                    <ul>
                      <details>
                        <summary><b>Minimum-Snap Trajectory Generator</b></summary>
                        <p>This implementation of the trajectory generator is based on the seminal work by Vijay Kumar and colleagues, specifically their paper on <b>Minimum snap trajectory generation and control for quadrotors</b>. It computes smooth, dynamically feasible trajectories for a quadcopter by minimizing snap (the fourth derivative of position) while satisfying boundary conditions for position, velocity, acceleration, and jerk.</p>
                    
                        <h5>Overview</h5>
                        <p>The generator calculates polynomial trajectories for the quadcopter's six degrees of freedom: <b>x, y, z (position), roll, pitch, and yaw</b>. The trajectory is expressed as a seventh-order polynomial, chosen for its ability to satisfy constraints on position, velocity, acceleration, and jerk at both the start and end of the trajectory.</p>
                    
                        <h5>Equations</h5>
                        <p>The polynomial trajectory for a single axis is given by:</p>
                        <p style="text-align: center;">\( x(t) = a_7 t^7 + a_6 t^6 + a_5 t^5 + a_4 t^4 + a_3 t^3 + a_2 t^2 + a_1 t + a_0 \)</p>
                        <p>Where \( x(t) \) represents the position at time \( t \), and the coefficients \( a_0, a_1, \ldots, a_7 \) are determined to minimize the snap (fourth derivative of position):</p>
                        <p style="text-align: center;">\( \text{Snap} = \frac{d^4x(t)}{dt^4} \).</p>
                    
                        <h5>Boundary Conditions</h5>
                        <p>The trajectory ensures continuity and smoothness by satisfying the following constraints at the start (\( t = 0 \)) and end (\( t = T \)) of the trajectory:</p>
                        <ul>
                            <li>Position: \( x(0), x(T) \)</li>
                            <li>Velocity: \( \dot{x}(0), \dot{x}(T) = 0 \)</li>
                            <li>Acceleration: \( \ddot{x}(0), \ddot{x}(T) = 0 \)</li>
                            <li>Jerk: \( \dddot{x}(0), \dddot{x}(T) = 0 \)</li>
                        </ul>
                    
                        <h5>Matrix Formulation</h5>
                        <p>The coefficients \( a_0 \) to \( a_7 \) are computed by solving the linear system:</p>
                        <p style="text-align: center;">\( A \cdot \mathbf{c} = \mathbf{B} \)</p>
                        <p>Where:</p>
                        <ul>
                            <li>\( A \): The boundary condition matrix constructed using polynomial terms and their derivatives for the start and end times.</li>
                            <li>\( \mathbf{B} \): A vector containing the boundary conditions for position, velocity, acceleration, and jerk.</li>
                            <li>\( \mathbf{c} \): The vector of polynomial coefficients to be solved.</li>
                        </ul>
                    
                        <h5>Trajectory Evaluation</h5>
                        <p>The trajectory can be evaluated for position, velocity, acceleration, or jerk at any time \( t \) by taking successive derivatives of the polynomial:</p>
                        <ul>
                            <li>Position: \( x(t) \)</li>
                            <li>Velocity: \( \dot{x}(t) = 7a_7 t^6 + 6a_6 t^5 + \ldots + a_1 \)</li>
                            <li>Acceleration: \( \ddot{x}(t) = 42a_7 t^5 + 30a_6 t^4 + \ldots \)</li>
                            <li>Jerk: \( \dddot{x}(t) = 210a_7 t^4 + 120a_6 t^3 + \ldots \)</li>
                        </ul>
                    
                        <h5>Key Features</h5>
                        <ul>
                            <li><b>Optimal Smoothness:</b> By minimizing snap, the trajectory ensures smooth and efficient motion with minimal actuator effort.</li>
                            <li><b>Flexibility:</b> The generator can handle arbitrary boundary conditions for all six degrees of freedom.</li>
                            <li><b>Real-Time Update:</b> Coefficients can be recomputed dynamically if the starting conditions change mid-flight.</li>
                        </ul>
                    
                        <h5>Implementation Notes</h5>
                        <p>The generator constructs individual trajectories for each degree of freedom. The coefficients for each trajectory are precomputed using matrix inversion. At runtime, the polynomial is evaluated at the desired time points to obtain position, velocity, acceleration, or jerk.</p>
                    
                        <h5>Relevance</h5>
                        <p>This approach is crucial for precise quadrotor maneuvers, especially in scenarios requiring high-speed, aggressive, or dynamic flight. The implementation is directly inspired by Vijay Kumar's work, which has been widely adopted for trajectory planning in autonomous drones.</p>
                    </details>
                    




                    <details>
                      <summary><b>Controller Design</b></summary>
                      <p>
                          To enable the quadrotor to follow specified trajectories \( \sigma_T(t) = [r_T(t)^T, \psi_T(t)]^T \), the controller uses the following components:
                      </p><h5>Position and Velocity Errors</h5>
                          <p>
                              The errors on position and velocity are defined as:
                              \[
                              e_p = r - r_T, \quad e_v = \dot{r} - \dot{r}_T
                              \]
                          </p>
                          
                          <h5>Desired Force Vector</h5>
                          <p>
                              The desired force vector for the controller and the desired body frame z-axis are calculated as:
                              \[
                              F_{des} = -K_p e_p - K_v e_v + mg \mathbf{x}_W + m \ddot{r}_T
                              \]
                              Here, \( K_p \) and \( K_v \) are positive definite gain matrices. We assume \( \|F_{des}\| \neq 0 \).
                          </p>
                      <h5>Total Thrust</h5>
                          <p>
                              The desired force is projected onto the actual body frame z-axis to compute the total thrust:
                              \[
                              u_1 = F_{des} \cdot z_B
                              \]
                          </p>
                      <h5>Desired Orientation</h5>
                          <p>
                              To determine the desired orientation:
                              <ul>
                                  <li>The desired body frame z-axis:
                                      \[
                                      z_{B, des} = \frac{F_{des}}{\|F_{des}\|}
                                      \]
                                  </li>
                                  <li>Using the specified yaw angle \( \psi_T(t) \), the desired body frame x-axis and y-axis are:
                                      \[
                                      x_{C, des} = [\cos\psi_T, \sin\psi_T, 0]^T
                                      \]
                                      \[
                                      y_{B, des} = \frac{z_{B, des} \times x_{C, des}}{\|z_{B, des} \times x_{C, des}\|}, \quad x_{B, des} = y_{B, des} \times z_{B, des}
                                      \]
                                  </li>
                              </ul>
                              The desired rotation matrix is then:
                              \[
                              R_{des} = [x_{B, des}, y_{B, des}, z_{B, des}]
                              \]
                          </p>
                      <h5>Orientation and Angular Velocity Errors</h5>
                          <p>
                              The orientation error is defined as:
                              \[
                              e_R = \frac{1}{2}(R_{des}^T W R_B - W R_B^T R_{des})^\vee
                              \]
                              where \( \vee \) represents the vee map converting elements of \( \text{so}(3) \) to \( \mathbb{R}^3 \).
                          </p>
                          <p>
                              The angular velocity error is:
                              \[
                              e_\omega = \mathbf{B}[\omega_{BW}] - \mathbf{B}[\omega_{BW, T}]
                              \]
                          </p>
                      <h5>Desired Moments</h5>
                          <p>
                              The desired moments and the remaining three inputs are computed as:
                              \[
                              [u_2, u_3, u_4]^T = -K_R e_R - K_\omega e_\omega
                              \]
                              where \( K_R \) and \( K_\omega \) are diagonal gain matrices, allowing unique gains for roll, pitch, and yaw tracking.
                          </p>
                  </details>
                  
                    </ul>
                 
                    <h3>Results</h3>
                    <h4><b>PID sim</b></h4>
                    <h4><b>PID hardware</b></h4>
                    <h4><b>Minimum-snap sim</b></h4>
                    <h4><b>Minimum-snap hardware</b></h4>
                    
                <div class="col mb-md-0 text-center" data-aos="fade-up">
                  <p><a href="https://github.com/aawizard/quad_ws" class="readmore">Github</a></p>
                </div>
            </div>
            

        </div>
    </section>

</main><!-- End #main -->


  <!-- ======= Footer ======= -->
  <footer class="footer" role="contentinfo">
    <div class="container">
      <div class="row">

        <div class=" social text-center mx-auto">
          
          <a href="https://github.com/aawizard"><span class="bi bi-github"></span></a>
          <a href="mailto:aawizard@u.northwestern.edu"><span class="bi bi-envelope"></span></a>
          <!-- <a href="#"><span class="bi bi-instagram"></span></a> -->
          <a href="https://www.linkedin.com/in/ananya-agarwal-0b60a3192/"><span class="bi bi-linkedin"></span></a>
        </div>
      </div>
    </div>
  </footer>

  <a href="#" class="back-to-top d-flex align-items-center justify-content-center"><i class="bi bi-arrow-up-short"></i></a>

  <!-- Vendor JS Files -->
  <script src="../assets/vendor/aos/aos.js"></script>
  <script src="../assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="../assets/vendor/isotope-layout/isotope.pkgd.min.js"></script>
  <script src="../assets/vendor/swiper/swiper-bundle.min.js"></script>
  <script src="../assets/vendor/php-email-form/validate.js"></script>

  <!-- Template Main JS File -->
  <script src="../assets/js/main.js"></script>

</body>

</html>